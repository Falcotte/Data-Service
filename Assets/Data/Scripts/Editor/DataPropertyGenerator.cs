using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace AngryKoala.Data
{
    public static class DataPropertyGenerator
    {
        private const string _playerDataGeneratedFileName = "PlayerData.Properties.Generated.cs";
        private const string _gameDataGeneratedFileName = "GameData.Properties.Generated.cs";
        private const string _settingsDataGeneratedFileName = "SettingsData.Properties.Generated.cs";

        [MenuItem("Angry Koala/Data/Generate PlayerData Properties", false, 0)]
        private static void GeneratePlayerDataProperties()
        {
            GenerateProperties<PlayerData>(
                _playerDataGeneratedFileName,
                "PlayerDataPropertyGenerator");
        }

        [MenuItem("Angry Koala/Data/Generate GameData Properties", false, 1)]
        private static void GenerateGameDataProperties()
        {
            GenerateProperties<GameData>(
                _gameDataGeneratedFileName,
                "GameDataPropertyGenerator");
        }
        
        [MenuItem("Angry Koala/Data/Generate SettingsData Properties", false, 2)]
        private static void GenerateSettingsDataProperties()
        {
            GenerateProperties<SettingsData>(
                _settingsDataGeneratedFileName,
                "DataPropertyGenerator (SettingsData)");
        }

        private static void GenerateProperties<TData>(
            string generatedFileName,
            string generatorName) where TData : ScriptableObject
        {
            Type dataType = typeof(TData);

            FieldInfo[] fields = dataType.GetFields(
                BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);

            StringBuilder propertiesBuilder = new StringBuilder();

            foreach (FieldInfo field in fields)
            {
                if (!field.IsPrivate)
                {
                    continue;
                }

                if (field.GetCustomAttribute<SerializeField>() == null)
                {
                    continue;
                }

                string fieldName = field.Name;

                if (fieldName.StartsWith("<", StringComparison.Ordinal) ||
                    fieldName.StartsWith("m_", StringComparison.Ordinal) ||
                    field.GetCustomAttribute<HideInInspector>() != null)
                {
                    continue;
                }

                string propertyName = GetPropertyName(fieldName);
                string typeName = GetFriendlyTypeName(field.FieldType);

                propertiesBuilder.AppendLine($"        public {typeName} {propertyName}");
                propertiesBuilder.AppendLine("        {");
                propertiesBuilder.AppendLine($"            get => {fieldName};");
                propertiesBuilder.AppendLine($"            set => {fieldName} = value;");
                propertiesBuilder.AppendLine("        }");
                propertiesBuilder.AppendLine();
            }

            string propertiesBlock = propertiesBuilder.ToString().TrimEnd();

            if (string.IsNullOrEmpty(propertiesBlock))
            {
                Debug.LogWarning(
                    $"No matching [SerializeField] private fields found on {dataType.Name} to generate properties for.");
                return;
            }

            string namespaceName = dataType.Namespace ?? "AngryKoala.Data";

            string generatedCode = $@"using System;
using System.Collections.Generic;
using UnityEngine;

namespace {namespaceName}
{{
    /// <summary>
    /// This class is generated by {generatorName}.
    /// Any changes may be overwritten.
    /// </summary>
    public partial class {dataType.Name} : ScriptableObject
    {{
{propertiesBlock}
    }}
}}";

            WriteGeneratedFile<TData>(generatedFileName, generatedCode);
        }

        private static string GetPropertyName(string fieldName)
        {
            string cleanedFieldName = fieldName.TrimStart('_');

            if (string.IsNullOrEmpty(cleanedFieldName))
            {
                return fieldName;
            }

            if (cleanedFieldName.Length == 1)
            {
                return cleanedFieldName.ToUpperInvariant();
            }

            return char.ToUpperInvariant(cleanedFieldName[0]) + cleanedFieldName.Substring(1);
        }

        private static string GetFriendlyTypeName(Type type)
        {
            // Arrays
            if (type.IsArray)
            {
                Type elementType = type.GetElementType();
                string elementName = GetFriendlyTypeName(elementType);
                return $"{elementName}[]";
            }

            // C# keyword aliases
            if (type == typeof(int)) return "int";
            if (type == typeof(float)) return "float";
            if (type == typeof(bool)) return "bool";
            if (type == typeof(string)) return "string";
            if (type == typeof(double)) return "double";
            if (type == typeof(long)) return "long";
            if (type == typeof(short)) return "short";
            if (type == typeof(byte)) return "byte";
            if (type == typeof(char)) return "char";
            if (type == typeof(uint)) return "uint";
            if (type == typeof(ulong)) return "ulong";
            if (type == typeof(ushort)) return "ushort";
            if (type == typeof(decimal)) return "decimal";

            // UnityEngine types â€“ short name is fine with using UnityEngine;
            if (type.Namespace == "UnityEngine")
            {
                return type.Name;
            }

            // Generic types (List<>, Dictionary<,>, HashSet<>, etc.)
            if (type.IsGenericType)
            {
                Type genericDefinition = type.GetGenericTypeDefinition();
                Type[] genericArguments = type.GetGenericArguments();

                string genericTypeName;

                if (genericDefinition == typeof(List<>))
                {
                    genericTypeName = "List";
                }
                else if (genericDefinition == typeof(Dictionary<,>))
                {
                    genericTypeName = "Dictionary";
                }
                else if (genericDefinition == typeof(HashSet<>))
                {
                    genericTypeName = "HashSet";
                }
                else
                {
                    string rawName = genericDefinition.Name;
                    int backtickIndex = rawName.IndexOf('`');
                    genericTypeName = backtickIndex >= 0
                        ? rawName.Substring(0, backtickIndex)
                        : rawName;
                }

                string[] genericArgumentNames = new string[genericArguments.Length];
                for (int i = 0; i < genericArguments.Length; i++)
                {
                    genericArgumentNames[i] = GetFriendlyTypeName(genericArguments[i]);
                }

                return $"{genericTypeName}<{string.Join(", ", genericArgumentNames)}>";
            }

            return type.Name;
        }

        private static void WriteGeneratedFile<TData>(
            string generatedFileName,
            string code) where TData : ScriptableObject
        {
            TData tempInstance = ScriptableObject.CreateInstance<TData>();
            MonoScript monoScript = MonoScript.FromScriptableObject(tempInstance);
            UnityEngine.Object.DestroyImmediate(tempInstance);

            string originalPath = AssetDatabase.GetAssetPath(monoScript);
            if (string.IsNullOrEmpty(originalPath))
            {
                Debug.LogError($"Could not locate {typeof(TData).Name}.cs script asset.");
                return;
            }

            string directory = Path.GetDirectoryName(originalPath);
            if (string.IsNullOrEmpty(directory))
            {
                Debug.LogError($"Could not determine directory for {typeof(TData).Name}.cs.");
                return;
            }

            string generatedPath = Path.Combine(directory, generatedFileName);

            File.WriteAllText(generatedPath, code, Encoding.UTF8);
            AssetDatabase.Refresh();
        }
    }
}