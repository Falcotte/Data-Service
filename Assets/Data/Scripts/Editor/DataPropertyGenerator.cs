using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace AngryKoala.Data
{
    public static class DataPropertyGenerator
    {
        private const string _playerDataPropertiesFileName = "PlayerData.Properties.Generated.cs";
        private const string _gameDataPropertiesFileName = "GameData.Properties.Generated.cs";
        private const string _settingsDataPropertiesFileName = "SettingsData.Properties.Generated.cs";

        private const string _playerDataSROptionsFileName = "PlayerData.SROptions.Generated.cs";
        private const string _gameDataSROptionsFileName = "GameData.SROptions.Generated.cs";
        private const string _settingsDataSROptionsFileName = "SettingsData.SROptions.Generated.cs";

        [MenuItem("Angry Koala/Data/Generate PlayerData", priority = 0)]
        private static void GeneratePlayerData()
        {
            GenerateData<PlayerData>(_playerDataPropertiesFileName, _playerDataSROptionsFileName,
                "DataPropertyGenerator - PlayerData");
        }

        [MenuItem("Angry Koala/Data/Generate GameData", priority = 1)]
        private static void GenerateGameData()
        {
            GenerateData<GameData>(_gameDataPropertiesFileName, _gameDataSROptionsFileName,
                "DataPropertyGenerator - GameData");
        }

        [MenuItem("Angry Koala/Data/Generate SettingsData", priority = 2)]
        private static void GenerateSettingsData()
        {
            GenerateData<SettingsData>(_settingsDataPropertiesFileName, _settingsDataSROptionsFileName,
                "DataPropertyGenerator - SettingsData");
        }

        private static void GenerateData<TData>(string propertiesFileName, string srOptionsFileName,
            string generatorName) where TData : ScriptableObject
        {
            Type dataType = typeof(TData);

            FieldInfo[] fields = dataType.GetFields(
                BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);

            Dictionary<string, SRDataOptionSettings> optionsByPropertyName =
                GetSROptionsForData<TData>();
            
            StringBuilder propertiesBuilder = new StringBuilder();
            StringBuilder srOptionsBuilder = new StringBuilder();

            foreach (FieldInfo field in fields)
            {
                if (!field.IsPrivate)
                {
                    continue;
                }

                if (field.GetCustomAttribute<SerializeField>() == null)
                {
                    continue;
                }

                if (field.GetCustomAttribute<HideInInspector>() != null)
                {
                    continue;
                }

                string fieldName = field.Name;

                if (fieldName.StartsWith("<", StringComparison.Ordinal) ||
                    fieldName.StartsWith("m_", StringComparison.Ordinal))
                {
                    continue;
                }

                if (string.Equals(fieldName, "_srDataOptions", StringComparison.Ordinal))
                {
                    continue;
                }

                string propertyName = GetPropertyName(fieldName);
                string typeName = GetTypeName(field.FieldType);

                propertiesBuilder.AppendLine($"        public {typeName} {propertyName}");
                propertiesBuilder.AppendLine("        {");
                propertiesBuilder.AppendLine($"            get => {fieldName};");
                propertiesBuilder.AppendLine($"            set => {fieldName} = value;");
                propertiesBuilder.AppendLine("        }");
                propertiesBuilder.AppendLine();

                if (optionsByPropertyName.TryGetValue(propertyName, out SRDataOptionSettings settings) &&
                    settings.Enabled)
                {
                    AppendSROptionsProperty<TData>(srOptionsBuilder, field.FieldType, propertyName, settings);
                }
            }

            string propertiesBlock = propertiesBuilder.ToString().TrimEnd();
            string namespaceName = dataType.Namespace ?? "AngryKoala.Data";

            string generatedPropertiesCode = $@"using System;
using System.Collections.Generic;
using UnityEngine;

namespace {namespaceName}
{{
    /// <summary>
    /// This class is generated by {generatorName}.
    /// Any changes may be overwritten.
    /// </summary>
    public partial class {dataType.Name} : ScriptableObject
    {{
{propertiesBlock}
    }}
}}";

            WriteGeneratedFile<TData>(propertiesFileName, generatedPropertiesCode);

            string srOptionsProperties = srOptionsBuilder.ToString().TrimEnd();

            string generatedSROptionsCode = $@"#if SRDEBUGGER

using System.ComponentModel;
using AngryKoala.Data;
using AngryKoala.Services;
using SRDebugger;

/// <summary>
/// This class is generated by {generatorName}.
/// Any changes may be overwritten.
/// </summary>
public partial class SROptions
{{
{srOptionsProperties}
}}

#endif";

#if SRDEBUGGER
            WriteGeneratedFile<TData>(srOptionsFileName, generatedSROptionsCode);
#else
            TData tempInstance = ScriptableObject.CreateInstance<TData>();
            MonoScript monoScript = MonoScript.FromScriptableObject(tempInstance);
            UnityEngine.Object.DestroyImmediate(tempInstance);

            string directory = Path.GetDirectoryName(AssetDatabase.GetAssetPath(monoScript));
            string path = Path.Combine(directory, srOptionsFileName);

            if (File.Exists(path))
            {
                File.Delete(path);
                AssetDatabase.Refresh();
            }
#endif
        }
        
        private static Dictionary<string, SRDataOptionSettings> GetSROptionsForData<TData>()
            where TData : ScriptableObject
        {
            Dictionary<string, SRDataOptionSettings> result =
                new Dictionary<string, SRDataOptionSettings>(StringComparer.Ordinal);

            string[] guids = AssetDatabase.FindAssets($"t:{typeof(TData).Name}");
            if (guids == null || guids.Length == 0)
            {
                return result;
            }

            Array.Sort(guids, StringComparer.Ordinal);

            foreach (string guid in guids)
            {
                string assetPath = AssetDatabase.GUIDToAssetPath(guid);
                TData dataAsset = AssetDatabase.LoadAssetAtPath<TData>(assetPath);

                if (dataAsset == null)
                {
                    continue;
                }

                FieldInfo optionsField = typeof(TData).GetField(
                    "_srDataOptions",
                    BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);

                if (optionsField == null)
                {
                    continue;
                }

                if (optionsField.GetValue(dataAsset) is not List<SRDataOptionEntry> entries)
                {
                    continue;
                }

                foreach (SRDataOptionEntry entry in entries)
                {
                    if (entry == null)
                    {
                        continue;
                    }

                    SRDataOptionSettings settings = entry.Settings;
                    if (settings == null)
                    {
                        continue;
                    }

                    if (string.IsNullOrEmpty(entry.PropertyName))
                    {
                        continue;
                    }

                    string propertyName = entry.PropertyName;

                    if (!result.TryGetValue(propertyName, out SRDataOptionSettings existing))
                    {
                        result[propertyName] = settings;
                        continue;
                    }

                    if (!existing.Enabled && settings.Enabled)
                    {
                        result[propertyName] = settings;
                    }
                }
            }

            return result;
        }

        private static string GetPropertyName(string fieldName)
        {
            string cleanedFieldName = fieldName.TrimStart('_');

            if (string.IsNullOrEmpty(cleanedFieldName))
            {
                return fieldName;
            }

            if (cleanedFieldName.Length == 1)
            {
                return cleanedFieldName.ToUpperInvariant();
            }

            return char.ToUpperInvariant(cleanedFieldName[0]) + cleanedFieldName.Substring(1);
        }

        private static string GetTypeName(Type type)
        {
            if (type.IsArray)
            {
                Type elementType = type.GetElementType();
                string elementName = GetTypeName(elementType);
                return $"{elementName}[]";
            }

            if (type == typeof(int)) return "int";
            if (type == typeof(float)) return "float";
            if (type == typeof(bool)) return "bool";
            if (type == typeof(string)) return "string";
            if (type == typeof(double)) return "double";
            if (type == typeof(long)) return "long";
            if (type == typeof(short)) return "short";
            if (type == typeof(byte)) return "byte";
            if (type == typeof(char)) return "char";
            if (type == typeof(uint)) return "uint";
            if (type == typeof(ulong)) return "ulong";
            if (type == typeof(ushort)) return "ushort";
            if (type == typeof(decimal)) return "decimal";

            if (type.Namespace == "UnityEngine")
            {
                return type.Name;
            }

            if (type.IsGenericType)
            {
                Type genericDefinition = type.GetGenericTypeDefinition();
                Type[] genericArguments = type.GetGenericArguments();

                string rawName = genericDefinition.Name;
                int backtickIndex = rawName.IndexOf('`');
                string genericTypeName = backtickIndex >= 0
                    ? rawName.Substring(0, backtickIndex)
                    : rawName;

                string[] genericArgumentNames = new string[genericArguments.Length];
                for (int i = 0; i < genericArguments.Length; i++)
                {
                    genericArgumentNames[i] = GetTypeName(genericArguments[i]);
                }

                return $"{genericTypeName}<{string.Join(", ", genericArgumentNames)}>";
            }

            return type.Name;
        }

        private static void AppendSROptionsProperty<TData>(StringBuilder builder, Type fieldType, string propertyName,
            SRDataOptionSettings settings) where TData : ScriptableObject
        {
            string dataTypeName = typeof(TData).Name;
            string srPropertyName = dataTypeName + propertyName;
            
            if (!string.IsNullOrEmpty(settings.Category))
            {
                builder.AppendLine($"    [Category(\"{SanitizeAttributeString(settings.Category)}\")]");
            }

            if (!string.IsNullOrEmpty(settings.DisplayName))
            {
                builder.AppendLine($"    [DisplayName(\"{SanitizeAttributeString(settings.DisplayName)}\")]");
            }

            if (settings.Sort != 0)
            {
                builder.AppendLine($"    [Sort({settings.Sort})]");
            }

            bool isNumeric =
                fieldType == typeof(int) ||
                fieldType == typeof(uint) ||
                fieldType == typeof(short) ||
                fieldType == typeof(ushort) ||
                fieldType == typeof(byte) ||
                fieldType == typeof(sbyte) ||
                fieldType == typeof(float) ||
                fieldType == typeof(double);

            if (isNumeric && settings.NumberRange != null && settings.NumberRange.Enabled)
            {
                string minString = settings.NumberRange.Min.ToString(System.Globalization.CultureInfo.InvariantCulture);
                string maxString = settings.NumberRange.Max.ToString(System.Globalization.CultureInfo.InvariantCulture);

                builder.AppendLine($"    [NumberRange({minString}, {maxString})]");
            }

            if (isNumeric && Math.Abs(settings.Increment) > double.Epsilon &&
                Math.Abs(settings.Increment - 1d) > double.Epsilon)
            {
                string incrementString = settings.Increment.ToString(System.Globalization.CultureInfo.InvariantCulture);

                builder.AppendLine($"    [Increment({incrementString})]");
            }

            string dataServiceAccessor = $"DataService.{dataTypeName}";
            string typeName = GetTypeName(fieldType);

            builder.AppendLine($"    public {typeName} {srPropertyName}");
            builder.AppendLine("    {");
            builder.AppendLine($"        get => {dataServiceAccessor}.{propertyName};");
            builder.AppendLine($"        set => {dataServiceAccessor}.{propertyName} = value;");
            builder.AppendLine("    }");
            builder.AppendLine();
        }

        private static string SanitizeAttributeString(string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                return string.Empty;
            }

            return value.Replace("\\", "\\\\").Replace("\"", "\\\"");
        }

        private static void WriteGeneratedFile<TData>(string generatedFileName, string code)
            where TData : ScriptableObject
        {
            TData tempInstance = ScriptableObject.CreateInstance<TData>();
            MonoScript monoScript = MonoScript.FromScriptableObject(tempInstance);
            UnityEngine.Object.DestroyImmediate(tempInstance);

            string originalPath = AssetDatabase.GetAssetPath(monoScript);
            if (string.IsNullOrEmpty(originalPath))
            {
                Debug.LogError($"Could not locate {typeof(TData).Name}.cs script asset.");
                return;
            }

            string directory = Path.GetDirectoryName(originalPath);
            if (string.IsNullOrEmpty(directory))
            {
                Debug.LogError($"Could not determine directory for {typeof(TData).Name}.cs.");
                return;
            }

            string generatedPath = Path.Combine(directory, generatedFileName);

            File.WriteAllText(generatedPath, code, Encoding.UTF8);
            AssetDatabase.Refresh();
        }
    }
}